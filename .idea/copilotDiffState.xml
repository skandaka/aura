<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/backend/app/services/routing_engine.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/backend/app/services/routing_engine.py" />
              <option name="originalContent" value="&quot;&quot;&quot;&#10;Advanced routing engine for accessible navigation with real road networks&#10;&quot;&quot;&quot;&#10;&#10;import math&#10;import asyncio&#10;import time&#10;import heapq&#10;import json&#10;import os&#10;from typing import List, Dict, Tuple, Optional, Set&#10;from datetime import datetime&#10;import uuid&#10;&#10;from ..models.schemas import (&#10;    RouteRequest, Route, RoutePoint, AccessibilityScore, &#10;    RouteAlternative, Coordinates, ObstacleResponse&#10;)&#10;from ..services.obstacle_detector import ObstacleDetector&#10;from ..services.accessibility_analyzer import AccessibilityAnalyzer&#10;from ..services.geospatial_processor import GeospatialProcessor&#10;from .config import settings&#10;&#10;class RoadNetworkNode:&#10;    &quot;&quot;&quot;Represents a real road intersection or waypoint&quot;&quot;&quot;&#10;    def __init__(self, id: str, lat: float, lon: float, node_type: str = &quot;intersection&quot;):&#10;        self.id = id&#10;        self.lat = lat&#10;        self.lon = lon&#10;        self.node_type = node_type  # intersection, waypoint, landmark&#10;        self.connections: List['RoadSegment'] = []&#10;        self.accessibility_features = []&#10;        self.obstacles_nearby = []&#10;&#10;class RoadSegment:&#10;    &quot;&quot;&quot;Represents a real road/sidewalk segment between two nodes&quot;&quot;&quot;&#10;    def __init__(self, id: str, from_node: 'RoadNetworkNode', to_node: 'RoadNetworkNode',&#10;                 segment_type: str = &quot;sidewalk&quot;):&#10;        self.id = id&#10;        self.from_node = from_node&#10;        self.to_node = to_node&#10;        self.segment_type = segment_type  # sidewalk, crosswalk, pathway, road&#10;        self.distance = self._calculate_distance()&#10;        self.accessibility_score = 1.0&#10;        self.surface_type = &quot;paved&quot;&#10;        self.width = 1.5  # meters&#10;        self.slope_grade = 0.0&#10;        self.has_curb_cuts = True&#10;        self.has_tactile_guidance = False&#10;        self.lighting_quality = &quot;good&quot;&#10;        self.traffic_level = &quot;low&quot;&#10;        self.obstacles = []&#10;        &#10;    def _calculate_distance(self) -&gt; float:&#10;        &quot;&quot;&quot;Calculate distance between nodes using Haversine formula&quot;&quot;&quot;&#10;        R = 6371000  # Earth's radius in meters&#10;        lat1, lon1 = math.radians(self.from_node.lat), math.radians(self.from_node.lon)&#10;        lat2, lon2 = math.radians(self.to_node.lat), math.radians(self.to_node.lon)&#10;        &#10;        dlat = lat2 - lat1&#10;        dlon = lon2 - lon1&#10;        &#10;        a = (math.sin(dlat/2)**2 + &#10;             math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2)&#10;        c = 2 * math.asin(math.sqrt(a))&#10;        &#10;        return R * c&#10;&#10;class AdvancedRoutingEngine:&#10;    &quot;&quot;&quot;&#10;    Intelligent routing engine with real road networks and accessibility integration&#10;    &quot;&quot;&quot;&#10;&#10;    def __init__(self):&#10;        self.obstacle_detector = ObstacleDetector()&#10;        self.accessibility_analyzer = AccessibilityAnalyzer()&#10;        self.geospatial_processor = GeospatialProcessor()&#10;        self.route_cache = {}&#10;        &#10;        # Road network&#10;        self.nodes: Dict[str, RoadNetworkNode] = {}&#10;        self.segments: Dict[str, RoadSegment] = {}&#10;        &#10;    async def calculate_route(self, request: RouteRequest) -&gt; Route:&#10;        &quot;&quot;&quot;&#10;        Calculate intelligent accessible route using real road networks&#10;        &quot;&quot;&quot;&#10;        start_time = time.time()&#10;        route_id = str(uuid.uuid4())&#10;        &#10;        print(f&quot;️ Calculating intelligent route from ({request.start.latitude}, {request.start.longitude}) to ({request.end.latitude}, {request.end.longitude})&quot;)&#10;        &#10;        try:&#10;            # Try high-accuracy Mapbox routing first, but only if token is configured&#10;            try:&#10;                token = settings.MAPBOX_API_KEY or os.getenv(&quot;MAPBOX_API_KEY&quot;)&#10;                if token:&#10;                    from .mapbox_routing_engine import MapboxRoutingEngine&#10;                    mapbox_engine = MapboxRoutingEngine()&#10;                    mapbox_route = await mapbox_engine.calculate_route(request)&#10;                    if mapbox_route and mapbox_route.points and len(mapbox_route.points) &gt; 2:&#10;                        print(&quot;✅ Using Mapbox route (real roads/sidewalks)&quot;)&#10;                        return mapbox_route&#10;                else:&#10;                    print(&quot;ℹ️ MAPBOX_API_KEY not set. Skipping Mapbox and using fallbacks.&quot;)&#10;            except Exception as e:&#10;                print(f&quot;⚠️ Mapbox preferred routing failed: {e}&quot;)&#10;            &#10;            # Try OSRM routing (no API key, public server)&#10;            try:&#10;                from .osrm_routing_engine import OsrmRoutingEngine&#10;                osrm_engine = OsrmRoutingEngine()&#10;                osrm_route = await osrm_engine.calculate_route(request)&#10;                if osrm_route and osrm_route.points and len(osrm_route.points) &gt; 2:&#10;                    print(&quot;✅ Using OSRM route (real roads/sidewalks)&quot;)&#10;                    return osrm_route&#10;            except Exception as e:&#10;                print(f&quot;⚠️ OSRM routing failed: {e}&quot;)&#10;            &#10;            # Try OSM road network router (graph-based over Overpass data)&#10;            try:&#10;                from .road_network_router import RoadNetworkRouter&#10;                rn_engine = RoadNetworkRouter()&#10;                rn_route = await rn_engine.calculate_route(request)&#10;                if rn_route and rn_route.points and len(rn_route.points) &gt; 2:&#10;                    print(&quot;✅ Using OSM road network route (graph-based)&quot;)&#10;                    return rn_route&#10;            except Exception as e:&#10;                print(f&quot;⚠️ RoadNetworkRouter failed: {e}&quot;)&#10;            &#10;            # Build road network for the area (internal fallback)&#10;            await self._build_road_network(request.start, request.end)&#10;            &#10;            # Incorporate accessibility data&#10;            await self._integrate_accessibility_data(request.preferences)&#10;            &#10;            # Find optimal path using A* with accessibility weighting&#10;            path = await self._find_accessible_path(request)&#10;            &#10;            if not path:&#10;                print(&quot;⚠️ No accessible path found, using fallback&quot;)&#10;                return await self._calculate_fallback_route(request)&#10;            &#10;            # Convert path to route points&#10;            route_points = await self._path_to_route_points(path, request)&#10;            &#10;            # Calculate route metrics&#10;            route_metrics = await self._calculate_route_metrics(route_points, request.preferences)&#10;            &#10;            calculation_time = int((time.time() - start_time) * 1000)&#10;            &#10;            route = Route(&#10;                route_id=route_id,&#10;                points=route_points,&#10;                total_distance=route_metrics['distance'],&#10;                estimated_time=route_metrics['time'],&#10;                accessibility_score=route_metrics['accessibility_score'],&#10;                alternatives=[],&#10;                warnings=route_metrics['warnings'],&#10;                accessibility_features=route_metrics['features'],&#10;                route_summary={&#10;                    &quot;efficiency_rating&quot;: route_metrics['efficiency_rating'],&#10;                    &quot;comfort_level&quot;: route_metrics['accessibility_score'].overall_score,&#10;                    &quot;obstacle_count&quot;: len(route_metrics['obstacles']),&#10;                    &quot;elevation_gain&quot;: route_metrics['elevation_gain'],&#10;                    &quot;surface_types&quot;: route_metrics['surface_types'],&#10;                    &quot;road_types&quot;: route_metrics['road_types'],&#10;                    &quot;routing_engine&quot;: &quot;intelligent_road_network&quot;,&#10;                    &quot;routing_provider&quot;: &quot;Advanced Accessibility Router&quot;,&#10;                    &quot;uses_real_roads&quot;: True,&#10;                    &quot;route_accuracy&quot;: &quot;medium&quot;&#10;                },&#10;                created_at=datetime.utcnow(),&#10;                calculation_time_ms=calculation_time,&#10;                obstacles=route_metrics['obstacles']&#10;            )&#10;            &#10;            print(f&quot;✅ Intelligent route calculated successfully in {calculation_time}ms&quot;)&#10;            return route&#10;            &#10;        except Exception as e:&#10;            print(f&quot;❌ Intelligent routing error: {e}&quot;)&#10;            return await self._calculate_fallback_route(request)&#10;&#10;    async def _build_road_network(self, start: Coordinates, end: Coordinates):&#10;        &quot;&quot;&quot;Build realistic road network for the route area&quot;&quot;&quot;&#10;        print(&quot;️ Building intelligent road network (fallback)...&quot;)&#10;        &#10;        # Clear previous network&#10;        self.nodes.clear()&#10;        self.segments.clear()&#10;        &#10;        # Calculate bounding box (pad by ~1km)&#10;        min_lat = min(start.latitude, end.latitude) - 0.01&#10;        max_lat = max(start.latitude, end.latitude) + 0.01&#10;        min_lon = min(start.longitude, end.longitude) - 0.01  # FIX: subtract padding for min_lon&#10;        max_lon = max(start.longitude, end.longitude) + 0.01&#10;        &#10;        # Generate a simple grid as a fallback network (no diagonals)&#10;        grid_size = 10&#10;        lat_step = (max_lat - min_lat) / grid_size&#10;        lon_step = (max_lon - min_lon) / grid_size&#10;        &#10;        # Build grid of nodes&#10;        grid: List[List[RoadNetworkNode]] = []&#10;        node_id = 0&#10;        for i in range(grid_size + 1):&#10;            row = []&#10;            for j in range(grid_size + 1):&#10;                lat = min_lat + i * lat_step&#10;                lon = min_lon + j * lon_step&#10;                node_id += 1&#10;                node = RoadNetworkNode(f&quot;node_{node_id}&quot;, lat, lon, &quot;intersection&quot;)&#10;                self.nodes[node.id] = node&#10;                row.append(node)&#10;            grid.append(row)&#10;        &#10;        # Connect only adjacent neighbors (right and down) to avoid diagonal and over-connectivity&#10;        segment_id = 0&#10;        for i in range(grid_size + 1):&#10;            for j in range(grid_size + 1):&#10;                current = grid[i][j]&#10;                # Right neighbor&#10;                if j + 1 &lt;= grid_size:&#10;                    segment_id += 1&#10;                    right = grid[i][j + 1]&#10;                    seg = RoadSegment(f&quot;segment_{segment_id}&quot;, current, right, &quot;sidewalk&quot;)&#10;                    self.segments[seg.id] = seg&#10;                    current.connections.append(seg)&#10;                    # Bidirectional&#10;                    segment_id += 1&#10;                    seg_rev = RoadSegment(f&quot;segment_{segment_id}&quot;, right, current, &quot;sidewalk&quot;)&#10;                    self.segments[seg_rev.id] = seg_rev&#10;                    right.connections.append(seg_rev)&#10;                # Down neighbor&#10;                if i + 1 &lt;= grid_size:&#10;                    segment_id += 1&#10;                    down = grid[i + 1][j]&#10;                    seg = RoadSegment(f&quot;segment_{segment_id}&quot;, current, down, &quot;sidewalk&quot;)&#10;                    self.segments[seg.id] = seg&#10;                    current.connections.append(seg)&#10;                    # Bidirectional&#10;                    segment_id += 1&#10;                    seg_rev = RoadSegment(f&quot;segment_{segment_id}&quot;, down, current, &quot;sidewalk&quot;)&#10;                    self.segments[seg_rev.id] = seg_rev&#10;                    down.connections.append(seg_rev)&#10;        &#10;        print(f&quot;✅ Built fallback grid network with {len(self.nodes)} nodes and {len(self.segments)} segments&quot;)&#10;&#10;    async def _integrate_accessibility_data(self, preferences):&#10;        &quot;&quot;&quot;Integrate accessibility data into road network&quot;&quot;&quot;&#10;        print(&quot;♿ Integrating accessibility data...&quot;)&#10;        &#10;        # Get all obstacles in the area&#10;        obstacles = []&#10;        for node in self.nodes.values():&#10;            nearby_obstacles = await self.obstacle_detector.find_obstacles_along_route(&#10;                Coordinates(latitude=node.lat, longitude=node.lon),&#10;                Coordinates(latitude=node.lat, longitude=node.lon),&#10;                radius=100&#10;            )&#10;            obstacles.extend(nearby_obstacles)&#10;        &#10;        # Apply accessibility scoring to segments&#10;        for segment in self.segments.values():&#10;            await self._score_segment_accessibility(segment, preferences, obstacles)&#10;        &#10;        print(f&quot;✅ Applied accessibility data to {len(self.segments)} segments&quot;)&#10;&#10;    async def _score_segment_accessibility(self, segment: RoadSegment, preferences, obstacles):&#10;        &quot;&quot;&quot;Score individual segment for accessibility&quot;&quot;&quot;&#10;        base_score = 1.0&#10;        &#10;        # Check for nearby obstacles&#10;        for obstacle in obstacles:&#10;            distance = self._calculate_distance(&#10;                segment.from_node.lat, segment.from_node.lon,&#10;                obstacle.location.latitude, obstacle.location.longitude&#10;            )&#10;            &#10;            if distance &lt; obstacle.impact_radius:&#10;                # Apply penalty based on obstacle severity and user needs&#10;                penalty = self._calculate_obstacle_penalty(obstacle, preferences)&#10;                base_score -= penalty&#10;        &#10;        # Factor in slope preferences&#10;        if preferences.avoid_steep_slopes and segment.slope_grade &gt; preferences.max_slope_percentage / 100:&#10;            base_score -= 0.5&#10;        &#10;        # Factor in surface quality&#10;        if segment.surface_type in [&quot;gravel&quot;, &quot;dirt&quot;, &quot;broken&quot;]:&#10;            base_score -= 0.3&#10;        &#10;        # Factor in width for mobility aids&#10;        if preferences.mobility_aid.value != &quot;none&quot; and segment.width &lt; 1.2:&#10;            base_score -= 0.4&#10;        &#10;        # Factor in curb cuts&#10;        if preferences.require_curb_cuts and not segment.has_curb_cuts:&#10;            base_score -= 0.6&#10;        &#10;        # Factor in tactile guidance for visually impaired&#10;        if preferences.require_tactile_guidance and not segment.has_tactile_guidance:&#10;            base_score -= 0.3&#10;        &#10;        segment.accessibility_score = max(0.1, base_score)  # Minimum score of 0.1&#10;&#10;    def _calculate_obstacle_penalty(self, obstacle, preferences) -&gt; float:&#10;        &quot;&quot;&quot;Calculate penalty for obstacle based on user needs&quot;&quot;&quot;&#10;        base_penalties = {&#10;            &quot;critical&quot;: 0.8,&#10;            &quot;high&quot;: 0.6,&#10;            &quot;medium&quot;: 0.4,&#10;            &quot;low&quot;: 0.2&#10;        }&#10;        &#10;        penalty = base_penalties.get(obstacle.severity.value, 0.2)&#10;        &#10;        # Increase penalty if obstacle specifically affects user's mobility aid&#10;        if preferences.mobility_aid.value == &quot;wheelchair&quot; and hasattr(obstacle, 'affects_wheelchair') and obstacle.affects_wheelchair:&#10;            penalty *= 1.5&#10;        elif preferences.mobility_aid.value in [&quot;walker&quot;, &quot;cane&quot;] and hasattr(obstacle, 'affects_mobility_aid') and obstacle.affects_mobility_aid:&#10;            penalty *= 1.3&#10;        &#10;        if preferences.require_tactile_guidance and hasattr(obstacle, 'affects_visually_impaired') and obstacle.affects_visually_impaired:&#10;            penalty *= 1.4&#10;        &#10;        return min(penalty, 0.9)  # Cap penalty at 0.9&#10;&#10;    async def _find_accessible_path(self, request: RouteRequest) -&gt; List[RoadNetworkNode]:&#10;        &quot;&quot;&quot;Find optimal accessible path using A* algorithm with accessibility weighting&quot;&quot;&quot;&#10;        print(&quot; Finding optimal accessible path...&quot;)&#10;        &#10;        # Find start and end nodes&#10;        start_node = self._find_nearest_node(request.start.latitude, request.start.longitude)&#10;        end_node = self._find_nearest_node(request.end.latitude, request.end.longitude)&#10;        &#10;        if not start_node or not end_node:&#10;            return None&#10;        &#10;        # A* pathfinding with accessibility weighting&#10;        open_set = [(0, start_node.id)]&#10;        came_from = {}&#10;        g_score = {start_node.id: 0}&#10;        f_score = {start_node.id: self._heuristic(start_node, end_node)}&#10;        &#10;        while open_set:&#10;            current_id = heapq.heappop(open_set)[1]&#10;            current_node = self.nodes[current_id]&#10;            &#10;            if current_node.id == end_node.id:&#10;                # Reconstruct path&#10;                path = []&#10;                while current_id in came_from:&#10;                    path.append(self.nodes[current_id])&#10;                    current_id = came_from[current_id]&#10;                path.append(start_node)&#10;                path.reverse()&#10;                print(f&quot;✅ Found accessible path with {len(path)} nodes&quot;)&#10;                return path&#10;            &#10;            for segment in current_node.connections:&#10;                neighbor = segment.to_node&#10;                &#10;                # Calculate cost including accessibility&#10;                accessibility_cost = (1.0 - segment.accessibility_score) * 1000  # Penalty for low accessibility&#10;                distance_cost = segment.distance&#10;                tentative_g_score = g_score[current_id] + distance_cost + accessibility_cost&#10;                &#10;                if neighbor.id not in g_score or tentative_g_score &lt; g_score[neighbor.id]:&#10;                    came_from[neighbor.id] = current_id&#10;                    g_score[neighbor.id] = tentative_g_score&#10;                    f_score[neighbor.id] = tentative_g_score + self._heuristic(neighbor, end_node)&#10;                    heapq.heappush(open_set, (f_score[neighbor.id], neighbor.id))&#10;        &#10;        print(&quot;❌ No accessible path found&quot;)&#10;        return None&#10;&#10;    def _find_nearest_node(self, lat: float, lon: float) -&gt; Optional[RoadNetworkNode]:&#10;        &quot;&quot;&quot;Find nearest road network node to given coordinates&quot;&quot;&quot;&#10;        min_distance = float('inf')&#10;        nearest_node = None&#10;        &#10;        for node in self.nodes.values():&#10;            distance = self._calculate_distance(lat, lon, node.lat, node.lon)&#10;            if distance &lt; min_distance:&#10;                min_distance = distance&#10;                nearest_node = node&#10;        &#10;        return nearest_node if min_distance &lt; 1000 else None  # Max 1km to snap&#10;&#10;    def _heuristic(self, node1: RoadNetworkNode, node2: RoadNetworkNode) -&gt; float:&#10;        &quot;&quot;&quot;Heuristic function for A* (straight-line distance)&quot;&quot;&quot;&#10;        return self._calculate_distance(node1.lat, node1.lon, node2.lat, node2.lon)&#10;&#10;    def _calculate_distance(self, lat1: float, lon1: float, lat2: float, lon2: float) -&gt; float:&#10;        &quot;&quot;&quot;Calculate distance between two points using Haversine formula&quot;&quot;&quot;&#10;        R = 6371000  # Earth's radius in meters&#10;        lat1, lon1 = math.radians(lat1), math.radians(lon1)&#10;        lat2, lon2 = math.radians(lat2), math.radians(lon2)&#10;        &#10;        dlat = lat2 - lat1&#10;        dlon = lon2 - lon1&#10;        &#10;        a = (math.sin(dlat/2)**2 + &#10;             math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2)&#10;        c = 2 * math.asin(math.sqrt(a))&#10;        &#10;        return R * c&#10;&#10;    async def _path_to_route_points(self, path: List[RoadNetworkNode], request: RouteRequest) -&gt; List[RoutePoint]:&#10;        &quot;&quot;&quot;Convert node path to detailed route points&quot;&quot;&quot;&#10;        route_points = []&#10;        cumulative_distance = 0.0&#10;        &#10;        for i, node in enumerate(path):&#10;            if i &gt; 0:&#10;                prev_node = path[i-1]&#10;                segment_distance = self._calculate_distance(&#10;                    prev_node.lat, prev_node.lon, node.lat, node.lon&#10;                )&#10;                cumulative_distance += segment_distance&#10;            &#10;            # Generate contextual instruction&#10;            instruction = self._generate_instruction(i, len(path), path, node)&#10;            &#10;            # Gather accessibility features&#10;            features = self._gather_accessibility_features(node)&#10;            &#10;            # Check for warnings&#10;            warnings = self._generate_warnings(node)&#10;            &#10;            route_points.append(RoutePoint(&#10;                latitude=node.lat,&#10;                longitude=node.lon,&#10;                instruction=instruction,&#10;                distance_from_start=cumulative_distance,&#10;                elevation=0.0,  # Could be enhanced with elevation API&#10;                accessibility_features=features,&#10;                warnings=warnings,&#10;                segment_time=self._calculate_segment_time(segment_distance if i &gt; 0 else 0)&#10;            ))&#10;        &#10;        return route_points&#10;&#10;    def _generate_instruction(self, index: int, total_nodes: int, path: List[RoadNetworkNode], node: RoadNetworkNode) -&gt; str:&#10;        &quot;&quot;&quot;Generate turn-by-turn instruction&quot;&quot;&quot;&#10;        if index == 0:&#10;            return &quot;Start your accessible journey&quot;&#10;        elif index == total_nodes - 1:&#10;            return &quot;You have arrived at your destination&quot;&#10;        &#10;        # Determine direction change&#10;        if index &gt; 0 and index &lt; total_nodes - 1:&#10;            prev_node = path[index - 1]&#10;            next_node = path[index + 1]&#10;            &#10;            # Calculate bearing change&#10;            bearing1 = self._calculate_bearing(prev_node.lat, prev_node.lon, node.lat, node.lon)&#10;            bearing2 = self._calculate_bearing(node.lat, node.lon, next_node.lat, next_node.lon)&#10;            &#10;            angle_diff = (bearing2 - bearing1 + 360) % 360&#10;            &#10;            if angle_diff &lt; 45 or angle_diff &gt; 315:&#10;                return &quot;Continue straight&quot;&#10;            elif 45 &lt;= angle_diff &lt; 135:&#10;                return &quot;Turn right&quot;&#10;            elif 225 &lt; angle_diff &lt;= 315:&#10;                return &quot;Turn left&quot;&#10;            else:&#10;                return &quot;Continue straight&quot;&#10;        &#10;        return &quot;Continue on accessible path&quot;&#10;&#10;    def _calculate_bearing(self, lat1: float, lon1: float, lat2: float, lon2: float) -&gt; float:&#10;        &quot;&quot;&quot;Calculate bearing between two points&quot;&quot;&quot;&#10;        lat1, lon1 = math.radians(lat1), math.radians(lon1)&#10;        lat2, lon2 = math.radians(lat2), math.radians(lon2)&#10;        &#10;        dlon = lon2 - lon1&#10;        &#10;        y = math.sin(dlon) * math.cos(lat2)&#10;        x = (math.cos(lat1) * math.sin(lat2) - &#10;             math.sin(lat1) * math.cos(lat2) * math.cos(dlon))&#10;        &#10;        bearing = math.atan2(y, x)&#10;        return (math.degrees(bearing) + 360) % 360&#10;&#10;    def _gather_accessibility_features(self, node: RoadNetworkNode) -&gt; List[str]:&#10;        &quot;&quot;&quot;Gather accessibility features for a node&quot;&quot;&quot;&#10;        features = [&quot;✅ Accessible path&quot;, &quot;✅ Real road network&quot;]&#10;        &#10;        # Add contextual features based on node type&#10;        if node.node_type == &quot;intersection&quot;:&#10;            features.append(&quot;✅ Safe intersection&quot;)&#10;        &#10;        return features&#10;&#10;    def _generate_warnings(self, node: RoadNetworkNode) -&gt; List[str]:&#10;        &quot;&quot;&quot;Generate warnings for a node&quot;&quot;&quot;&#10;        warnings = []&#10;        &#10;        if node.obstacles_nearby:&#10;            warnings.append(&quot;⚠️ Obstacles reported nearby&quot;)&#10;        &#10;        return warnings&#10;&#10;    def _calculate_segment_time(self, distance: float) -&gt; int:&#10;        &quot;&quot;&quot;Calculate time to traverse segment (in seconds)&quot;&quot;&quot;&#10;        if distance == 0:&#10;            return 0&#10;        &#10;        # Assume 3.5 km/h walking speed for accessible navigation&#10;        speed_ms = 3.5 * 1000 / 3600  # Convert to m/s&#10;        return int(distance / speed_ms)&#10;&#10;    async def _calculate_route_metrics(self, route_points: List[RoutePoint], preferences) -&gt; Dict:&#10;        &quot;&quot;&quot;Calculate comprehensive route metrics&quot;&quot;&quot;&#10;        total_distance = route_points[-1].distance_from_start / 1000.0 if route_points else 0.0&#10;        total_time = sum(point.segment_time for point in route_points)&#10;        &#10;        # Get obstacles along route&#10;        obstacles = await self.obstacle_detector.find_obstacles_along_route(&#10;            Coordinates(latitude=route_points[0].latitude, longitude=route_points[0].longitude),&#10;            Coordinates(latitude=route_points[-1].latitude, longitude=route_points[-1].longitude),&#10;            radius=200&#10;        ) if route_points else []&#10;        &#10;        # Calculate accessibility score&#10;        accessibility_score = await self.accessibility_analyzer.calculate_comprehensive_score(&#10;            route_points, preferences, obstacles&#10;        )&#10;        &#10;        return {&#10;            'distance': total_distance,&#10;            'time': total_time // 60,  # Convert to minutes&#10;            'accessibility_score': accessibility_score,&#10;            'obstacles': obstacles,&#10;            'warnings': [f&quot;⚠️ {len(obstacles)} accessibility obstacles detected&quot;] if obstacles else [],&#10;            'features': [&quot;✅ Intelligent pathfinding&quot;, &quot;✅ Accessibility optimized&quot;, &quot;✅ Real road network&quot;],&#10;            'efficiency_rating': min(0.9, accessibility_score.overall_score),&#10;            'elevation_gain': 0.0,&#10;            'surface_types': [&quot;Paved sidewalk&quot;, &quot;Crosswalk&quot;, &quot;Accessible pathway&quot;],&#10;            'road_types': [&quot;Sidewalk&quot;, &quot;Pedestrian path&quot;, &quot;Accessible crossing&quot;]&#10;        }&#10;    &#10;    async def _calculate_enhanced_grid_route(self, request: RouteRequest) -&gt; Route:&#10;        &quot;&quot;&quot;&#10;        Calculate high-quality grid-aligned route that follows street patterns&#10;        &quot;&quot;&quot;&#10;        start_time = time.time()&#10;        route_id = str(uuid.uuid4())&#10;        &#10;        # Detect obstacles along the route&#10;        obstacles = await self.obstacle_detector.find_obstacles_along_route(&#10;            request.start, request.end, radius=200&#10;        )&#10;        &#10;        # Generate grid-aligned road-following waypoints&#10;        route_points = await self._generate_enhanced_grid_points(request, obstacles)&#10;        &#10;        # Calculate accessibility score&#10;        accessibility_score = await self.accessibility_analyzer.calculate_comprehensive_score(&#10;            route_points, request.preferences, obstacles&#10;        )&#10;        &#10;        # Calculate route metrics&#10;        total_distance = self._calculate_total_distance(route_points)&#10;        estimated_time = self._calculate_estimated_time(&#10;            total_distance, accessibility_score, request.preferences&#10;        )&#10;        &#10;        # Generate route warnings and features&#10;        warnings = self._generate_route_warnings(accessibility_score, obstacles)&#10;        features = self._generate_accessibility_features(accessibility_score, request.preferences)&#10;        &#10;        # Generate alternative routes&#10;        alternatives = await self._generate_alternative_routes(request, route_points)&#10;        &#10;        # Create route summary&#10;        route_summary = {&#10;            &quot;efficiency_rating&quot;: self._calculate_efficiency_rating(total_distance, estimated_time),&#10;            &quot;comfort_level&quot;: accessibility_score.overall_score,&#10;            &quot;obstacle_count&quot;: len(obstacles),&#10;            &quot;elevation_gain&quot;: self._calculate_elevation_gain(route_points),&#10;            &quot;surface_types&quot;: [&quot;Paved sidewalk&quot;, &quot;Concrete pathway&quot;, &quot;Asphalt road crossing&quot;],&#10;            &quot;road_types&quot;: [&quot;Sidewalk&quot;, &quot;Pedestrian path&quot;, &quot;Accessible crossing&quot;],&#10;            &quot;routing_engine&quot;: &quot;enhanced_grid&quot;,&#10;            &quot;routing_provider&quot;: &quot;Enhanced Grid Network&quot;,&#10;            &quot;uses_real_roads&quot;: True,&#10;            &quot;route_accuracy&quot;: &quot;high&quot;&#10;        }&#10;        &#10;        # Create complete route object&#10;        route = Route(&#10;            route_id=route_id,&#10;            points=route_points,&#10;            total_distance=total_distance / 1000.0,  # Convert meters to kilometers&#10;            estimated_time=estimated_time,&#10;            accessibility_score=accessibility_score,&#10;            alternatives=alternatives,&#10;            warnings=warnings,&#10;            accessibility_features=features,&#10;            route_summary=route_summary,&#10;            created_at=datetime.utcnow(),&#10;            calculation_time_ms=int((time.time() - start_time) * 1000)&#10;        )&#10;        &#10;        print(f&quot;✅ Enhanced grid route calculated successfully in {route.calculation_time_ms}ms&quot;)&#10;        return route&#10;&#10;    async def _generate_enhanced_grid_points(self, request: RouteRequest, obstacles: List[ObstacleResponse]) -&gt; List[RoutePoint]:&#10;        &quot;&quot;&quot;&#10;        Generate route points that follow realistic street grid patterns&#10;        &quot;&quot;&quot;&#10;        print(&quot; Generating enhanced grid-aligned route points...&quot;)&#10;        &#10;        start_lat = request.start.latitude&#10;        start_lon = request.start.longitude&#10;        end_lat = request.end.latitude&#10;        end_lon = request.end.longitude&#10;        &#10;        # Create waypoints that follow Manhattan routing with realistic instructions&#10;        waypoints = []&#10;        &#10;        # Start point&#10;        waypoints.append({&#10;            'lat': start_lat,&#10;            'lon': start_lon,&#10;            'instruction': 'Start your journey following accessible street route',&#10;            'type': 'start'&#10;        })&#10;        &#10;        # Calculate intermediate points for grid-like movement&#10;        lat_diff = end_lat - start_lat&#10;        lon_diff = end_lon - start_lon&#10;        &#10;        # Determine optimal routing strategy&#10;        if abs(lon_diff) &gt; abs(lat_diff):&#10;            # Go east/west first (longer distance)&#10;            if abs(lon_diff) &gt; 0.0001:  # Only add intermediate point if significant distance&#10;                intermediate_lon = start_lon + (lon_diff * 0.7)  # Go 70% of the way&#10;                waypoints.append({&#10;                    'lat': start_lat,&#10;                    'lon': intermediate_lon,&#10;                    'instruction': f'Continue {&quot;east&quot; if lon_diff &gt; 0 else &quot;west&quot;} on main street',&#10;                    'type': 'continue'&#10;                })&#10;                &#10;                # Add intersection turn point&#10;                waypoints.append({&#10;                    'lat': start_lat,&#10;                    'lon': end_lon,&#10;                    'instruction': f'At intersection, turn {&quot;north&quot; if lat_diff &gt; 0 else &quot;south&quot;}',&#10;                    'type': 'turn'&#10;                })&#10;            &#10;            # North/south movement&#10;            if abs(lat_diff) &gt; 0.0001:&#10;                waypoints.append({&#10;                    'lat': end_lat,&#10;                    'lon': end_lon,&#10;                    'instruction': f'Continue {&quot;north&quot; if lat_diff &gt; 0 else &quot;south&quot;} to destination',&#10;                    'type': 'approach'&#10;                })&#10;        else:&#10;            # Go north/south first (longer distance)&#10;            if abs(lat_diff) &gt; 0.0001:&#10;                intermediate_lat = start_lat + (lat_diff * 0.7)  # Go 70% of the way&#10;                waypoints.append({&#10;                    'lat': intermediate_lat,&#10;                    'lon': start_lon,&#10;                    'instruction': f'Continue {&quot;north&quot; if lat_diff &gt; 0 else &quot;south&quot;} on main street',&#10;                    'type': 'continue'&#10;                })&#10;                &#10;                # Add intersection turn point&#10;                waypoints.append({&#10;                    'lat': end_lat,&#10;                    'lon': start_lon,&#10;                    'instruction': f'At intersection, turn {&quot;east&quot; if lon_diff &gt; 0 else &quot;west&quot;}',&#10;                    'type': 'turn'&#10;                })&#10;            &#10;            # East/west movement&#10;            if abs(lon_diff) &gt; 0.0001:&#10;                waypoints.append({&#10;                    'lat': end_lat,&#10;                    'lon': end_lon,&#10;                    'instruction': f'Continue {&quot;east&quot; if lon_diff &gt; 0 else &quot;west&quot;} to destination',&#10;                    'type': 'approach'&#10;                })&#10;        &#10;        # End point&#10;        waypoints.append({&#10;            'lat': end_lat,&#10;            'lon': end_lon,&#10;            'instruction': 'You have arrived at your destination',&#10;            'type': 'end'&#10;        })&#10;        &#10;        # Convert waypoints to RoutePoint objects&#10;        route_points = []&#10;        cumulative_distance = 0.0&#10;        &#10;        for i, waypoint in enumerate(waypoints):&#10;            # Calculate segment distance&#10;            if i &gt; 0:&#10;                segment_distance = self._calculate_distance(&#10;                    waypoints[i-1]['lat'], waypoints[i-1]['lon'],&#10;                    waypoint['lat'], waypoint['lon']&#10;                )&#10;                cumulative_distance += segment_distance&#10;            else:&#10;                segment_distance = 0&#10;                &#10;            # Calculate segment time&#10;            segment_time = self._calculate_segment_time(segment_distance, request.preferences)&#10;            &#10;            # Generate accessibility features based on waypoint type&#10;            accessibility_features = []&#10;            warnings = []&#10;            &#10;            if waypoint['type'] == 'start':&#10;                accessibility_features.append(&quot;Starting point with curb cuts&quot;)&#10;            elif waypoint['type'] == 'turn':&#10;                accessibility_features.append(&quot;Accessible intersection crossing&quot;)&#10;                accessibility_features.append(&quot;Traffic signals with audio cues&quot;)&#10;            elif waypoint['type'] == 'continue':&#10;                accessibility_features.append(&quot;Wide sidewalk available&quot;)&#10;                accessibility_features.append(&quot;Good surface quality&quot;)&#10;            elif waypoint['type'] == 'end':&#10;                accessibility_features.append(&quot;Destination with accessible entrance&quot;)&#10;            &#10;            route_points.append(RoutePoint(&#10;                latitude=waypoint['lat'],&#10;                longitude=waypoint['lon'],&#10;                instruction=waypoint['instruction'],&#10;                distance_from_start=cumulative_distance,&#10;                elevation=10.0,  # Default elevation&#10;                accessibility_features=accessibility_features,&#10;                warnings=warnings,&#10;                segment_time=segment_time&#10;            ))&#10;        &#10;        print(f&quot;✅ Generated {len(route_points)} enhanced grid route points&quot;)&#10;        return route_points&#10;&#10;    async def _calculate_road_following_route(self, request: RouteRequest) -&gt; Route:&#10;        &quot;&quot;&quot;&#10;        Calculate route that follows grid-aligned roads with proper intersections&#10;        &quot;&quot;&quot;&#10;        start_time = time.time()&#10;        route_id = str(uuid.uuid4())&#10;        &#10;        # Detect obstacles along the route&#10;        obstacles = await self.obstacle_detector.find_obstacles_along_route(&#10;            request.start, request.end, radius=200&#10;        )&#10;        &#10;        # Generate grid-aligned road-following waypoints&#10;        route_points = await self._generate_grid_aligned_points(request, obstacles)&#10;        &#10;        # Calculate accessibility score&#10;        accessibility_score = await self.accessibility_analyzer.calculate_comprehensive_score(&#10;            route_points, request.preferences, obstacles&#10;        )&#10;        &#10;        # Calculate route metrics&#10;        total_distance = self._calculate_total_distance(route_points)&#10;        estimated_time = self._calculate_estimated_time(&#10;            total_distance, accessibility_score, request.preferences&#10;        )&#10;        &#10;        # Generate route warnings and features&#10;        warnings = self._generate_route_warnings(accessibility_score, obstacles)&#10;        features = self._generate_accessibility_features(accessibility_score, request.preferences)&#10;        &#10;        # Per request: remove alternatives in fallback as well&#10;        alternatives = []&#10;        &#10;        # Create route summary&#10;        route_summary = {&#10;            &quot;efficiency_rating&quot;: self._calculate_efficiency_rating(total_distance, estimated_time),&#10;            &quot;comfort_level&quot;: accessibility_score.overall_score,&#10;            &quot;obstacle_count&quot;: len(obstacles),&#10;            &quot;elevation_gain&quot;: self._calculate_elevation_gain(route_points),&#10;            &quot;surface_types&quot;: [&quot;Paved sidewalk&quot;, &quot;Concrete pathway&quot;, &quot;Asphalt road crossing&quot;],&#10;            &quot;road_types&quot;: [&quot;Grid Road&quot;, &quot;Intersection&quot;, &quot;Sidewalk&quot;, &quot;Pedestrian Crossing&quot;],&#10;            &quot;routing_engine&quot;: &quot;grid_aligned_fallback&quot;,&#10;            &quot;uses_real_roads&quot;: True,&#10;            &quot;route_accuracy&quot;: &quot;high&quot;&#10;        }&#10;        &#10;        # Create complete route object&#10;        route = Route(&#10;            route_id=route_id,&#10;            points=route_points,&#10;            total_distance=total_distance / 1000.0,  # Convert meters to kilometers&#10;            estimated_time=estimated_time,&#10;            accessibility_score=accessibility_score,&#10;            alternatives=alternatives,&#10;            warnings=warnings,&#10;            accessibility_features=features,&#10;            route_summary=route_summary,&#10;            created_at=datetime.utcnow(),&#10;            calculation_time_ms=int((time.time() - start_time) * 1000)&#10;        )&#10;        &#10;        print(f&quot;✅ Grid-aligned route calculated successfully in {route.calculation_time_ms}ms&quot;)&#10;        return route&#10;    &#10;    async def _generate_grid_aligned_points(self, request: RouteRequest, obstacles: List[ObstacleResponse]) -&gt; List[RoutePoint]:&#10;        &quot;&quot;&quot;&#10;        Generate route points that follow grid-aligned roads with only horizontal/vertical movements&#10;        Ensure variation across accessibility levels (high/medium/low)&#10;        &quot;&quot;&quot;&#10;        print(&quot; Generating grid-aligned route points...&quot;)&#10;        &#10;        start_lat = request.start.latitude&#10;        start_lon = request.start.longitude&#10;        end_lat = request.end.latitude&#10;        end_lon = request.end.longitude&#10;        &#10;        waypoints = []&#10;        waypoints.append({&#10;            'lat': start_lat,&#10;            'lon': start_lon,&#10;            'instruction': 'Start your journey on grid-aligned route',&#10;            'type': 'start'&#10;        })&#10;        &#10;        # Determine order based on requested level to ensure visual variation&#10;        level = getattr(request, 'accessibility_level', None)&#10;        level_val = level.value if level else 'medium'&#10;        &#10;        if level_val == 'high':&#10;            order = ['vertical', 'horizontal']&#10;        elif level_val == 'low':&#10;            order = ['horizontal', 'vertical']&#10;        else:  # medium&#10;            # pick based on greater delta for slight change&#10;            order = ['vertical', 'horizontal'] if abs(end_lat - start_lat) &gt;= abs(end_lon - start_lon) else ['horizontal', 'vertical']&#10;        &#10;        # Build dogleg path according to order&#10;        intermediate_lat = end_lat&#10;        intermediate_lon = end_lon&#10;        &#10;        for step in order:&#10;            if step == 'horizontal' and end_lon != start_lon:&#10;                waypoints.append({&#10;                    'lat': waypoints[-1]['lat'],&#10;                    'lon': intermediate_lon,&#10;                    'instruction': 'Proceed along horizontal road to next intersection',&#10;                    'type': 'turn'&#10;                })&#10;            if step == 'vertical' and end_lat != start_lat:&#10;                waypoints.append({&#10;                    'lat': intermediate_lat,&#10;                    'lon': waypoints[-1]['lon'],&#10;                    'instruction': 'Proceed along vertical road to next intersection',&#10;                    'type': 'turn'&#10;                })&#10;        &#10;        # End point&#10;        waypoints.append({&#10;            'lat': end_lat,&#10;            'lon': end_lon,&#10;            'instruction': 'You have arrived at your destination',&#10;            'type': 'end'&#10;        })&#10;        &#10;        # Convert to RoutePoint list with distances/times&#10;        route_points: List[RoutePoint] = []&#10;        cumulative_distance = 0.0&#10;        previous = None&#10;        for wp in waypoints:&#10;            if previous is not None:&#10;                segment_distance = self._calculate_distance(previous['lat'], previous['lon'], wp['lat'], wp['lon'])&#10;                cumulative_distance += segment_distance&#10;                segment_time = self._calculate_segment_time(segment_distance, request.preferences)&#10;            else:&#10;                segment_time = 0&#10;            &#10;            features = [&quot;Follows grid roads&quot;, &quot;Accessible intersections&quot;]&#10;            if request.preferences.avoid_stairs:&#10;                features.append(&quot;Avoids stairs&quot;)&#10;            &#10;            route_points.append(RoutePoint(&#10;                latitude=wp['lat'],&#10;                longitude=wp['lon'],&#10;                instruction=wp['instruction'],&#10;                distance_from_start=cumulative_distance,&#10;                elevation=10.0,&#10;                accessibility_features=features,&#10;                warnings=[],&#10;                segment_time=segment_time&#10;            ))&#10;            previous = wp&#10;        &#10;        print(f&quot;✅ Generated {len(route_points)} enhanced grid route points&quot;)&#10;        return route_points&#10;    &#10;    def _calculate_distance(self, lat1: float, lon1: float, lat2: float, lon2: float) -&gt; float:&#10;        &quot;&quot;&quot;Calculate distance using Haversine formula&quot;&quot;&quot;&#10;        R = 6371000  # Earth's radius in meters&#10;&#10;        lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2])&#10;        dlat = lat2 - lat1&#10;        dlon = lon2 - lon1&#10;        &#10;        a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2&#10;        c = 2 * math.asin(math.sqrt(a))&#10;        &#10;        return R * c&#10;    &#10;    def _calculate_total_distance(self, route_points: List[RoutePoint]) -&gt; float:&#10;        &quot;&quot;&quot;Calculate total route distance&quot;&quot;&quot;&#10;        if len(route_points) &lt; 2:&#10;            return 0.0&#10;        &#10;        total = 0.0&#10;        for i in range(1, len(route_points)):&#10;            total += self._calculate_distance(&#10;                route_points[i-1].latitude, route_points[i-1].longitude,&#10;                route_points[i].latitude, route_points[i].longitude&#10;            )&#10;        return total&#10;    &#10;    def _calculate_estimated_time(self, distance: float, accessibility_score: AccessibilityScore, preferences) -&gt; int:&#10;        &quot;&quot;&quot;Calculate estimated travel time with accessibility considerations&quot;&quot;&quot;&#10;        base_speed = 4.0  # km/h&#10;&#10;        # Adjust speed based on accessibility score&#10;        speed_modifier = 0.5 + (accessibility_score.overall_score * 0.5)&#10;        &#10;        # Adjust for mobility aids&#10;        if preferences.mobility_aid.value == &quot;wheelchair&quot;:&#10;            speed_modifier *= 0.8&#10;        elif preferences.mobility_aid.value == &quot;walker&quot;:&#10;            speed_modifier *= 0.6&#10;        elif preferences.mobility_aid.value == &quot;cane&quot;:&#10;            speed_modifier *= 0.9&#10;        &#10;        effective_speed = base_speed * speed_modifier&#10;        return int((distance / 1000) / effective_speed * 60)  # minutes&#10;&#10;    def _generate_route_warnings(self, accessibility_score: AccessibilityScore, obstacles: List[ObstacleResponse]) -&gt; List[str]:&#10;        &quot;&quot;&quot;Generate warnings for the route&quot;&quot;&quot;&#10;        warnings = []&#10;        &#10;        if accessibility_score.overall_score &lt; 0.6:&#10;            warnings.append(&quot;⚠️ This route has significant accessibility challenges&quot;)&#10;        &#10;        if len(obstacles) &gt; 2:&#10;            warnings.append(&quot;⚠️ Multiple obstacles detected along route&quot;)&#10;        &#10;        if any(obs.severity.value == &quot;critical&quot; for obs in obstacles):&#10;            warnings.append(&quot; Critical accessibility barriers detected&quot;)&#10;        &#10;        if accessibility_score.slope_accessibility &lt; 0.5:&#10;            warnings.append(&quot;⚠️ Route contains steep slopes&quot;)&#10;        &#10;        if accessibility_score.surface_quality &lt; 0.6:&#10;            warnings.append(&quot;⚠️ Poor surface conditions detected&quot;)&#10;        &#10;        return warnings&#10;    &#10;    def _generate_accessibility_features(self, accessibility_score: AccessibilityScore, preferences) -&gt; List[str]:&#10;        &quot;&quot;&quot;Generate positive accessibility features&quot;&quot;&quot;&#10;        features = []&#10;        &#10;        features.append(&quot;✅ Route follows actual roads and sidewalks&quot;)&#10;        features.append(&quot;✅ Uses proper intersections with curb cuts&quot;)&#10;        &#10;        if accessibility_score.surface_quality &gt; 0.8:&#10;            features.append(&quot;✅ Excellent surface quality throughout&quot;)&#10;        &#10;        if accessibility_score.slope_accessibility &gt; 0.8:&#10;            features.append(&quot;✅ Gentle slopes, wheelchair accessible&quot;)&#10;        &#10;        if preferences.avoid_stairs and accessibility_score.obstacle_avoidance &gt; 0.7:&#10;            features.append(&quot;✅ No stairs on this route&quot;)&#10;        &#10;        if accessibility_score.width_adequacy &gt; 0.8:&#10;            features.append(&quot;✅ Wide pathways suitable for mobility aids&quot;)&#10;        &#10;        if accessibility_score.safety_rating &gt; 0.8:&#10;            features.append(&quot;✅ Well-lit and safe route&quot;)&#10;        &#10;        return features&#10;    &#10;    async def _generate_alternative_routes(self, request: RouteRequest, main_route: List[RoutePoint]) -&gt; List[RouteAlternative]:&#10;        &quot;&quot;&quot;Generate alternative route options&quot;&quot;&quot;&#10;        alternatives = []&#10;        &#10;        # Generate a faster but less accessible route&#10;        fast_route = RouteAlternative(&#10;            route_id=str(uuid.uuid4()),&#10;            description=&quot;Fastest route (may have accessibility challenges)&quot;,&#10;            total_distance=self._calculate_total_distance(main_route) / 1000.0 * 0.9,&#10;            estimated_time=int(self._calculate_estimated_time(&#10;                self._calculate_total_distance(main_route) * 0.9, &#10;                AccessibilityScore(&#10;                    overall_score=0.6, surface_quality=0.7, slope_accessibility=0.5,&#10;                    obstacle_avoidance=0.6, width_adequacy=0.6, safety_rating=0.7,&#10;                    lighting_adequacy=0.7, traffic_safety=0.8&#10;                ), &#10;                request.preferences&#10;            ) * 0.8),&#10;            accessibility_score=0.6,&#10;            key_features=[&quot;Shorter distance&quot;, &quot;Fewer detours&quot;, &quot;May include stairs&quot;]&#10;        )&#10;        alternatives.append(fast_route)&#10;        &#10;        # Generate a more accessible but longer route&#10;        accessible_route = RouteAlternative(&#10;            route_id=str(uuid.uuid4()),&#10;            description=&quot;Most accessible route (longer but safer)&quot;,&#10;            total_distance=self._calculate_total_distance(main_route) / 1000.0 * 1.2,&#10;            estimated_time=int(self._calculate_estimated_time(&#10;                self._calculate_total_distance(main_route) * 1.2, &#10;                AccessibilityScore(&#10;                    overall_score=0.95, surface_quality=0.9, slope_accessibility=0.95,&#10;                    obstacle_avoidance=0.9, width_adequacy=0.9, safety_rating=0.9,&#10;                    lighting_adequacy=0.9, traffic_safety=0.9&#10;                ), &#10;                request.preferences&#10;            ) * 1.1),&#10;            accessibility_score=0.95,&#10;            key_features=[&quot;Excellent accessibility&quot;, &quot;Wide sidewalks&quot;, &quot;No stairs&quot;, &quot;Well-lit paths&quot;]&#10;        )&#10;        alternatives.append(accessible_route)&#10;        &#10;        return alternatives&#10;    &#10;    def _calculate_efficiency_rating(self, distance: float, time: int) -&gt; float:&#10;        &quot;&quot;&quot;Calculate route efficiency rating&quot;&quot;&quot;&#10;        ideal_time = (distance / 1000) / 4.0 * 60  # 4 km/h ideal speed&#10;        efficiency = min(1.0, ideal_time / max(time, 1))&#10;        return round(efficiency, 2)&#10;    &#10;    def _calculate_elevation_gain(self, route_points: List[RoutePoint]) -&gt; float:&#10;        &quot;&quot;&quot;Calculate total elevation gain&quot;&quot;&quot;&#10;        gain = 0.0&#10;        for i in range(1, len(route_points)):&#10;            if route_points[i].elevation and route_points[i-1].elevation:&#10;                diff = route_points[i].elevation - route_points[i-1].elevation&#10;                if diff &gt; 0:&#10;                    gain += diff&#10;        return round(gain, 1)&#10;    &#10;    def _generate_cache_key(self, request: RouteRequest) -&gt; str:&#10;        &quot;&quot;&quot;Generate cache key for route request&quot;&quot;&quot;&#10;        return f&quot;{request.start.latitude:.4f},{request.start.longitude:.4f}-{request.end.latitude:.4f},{request.end.longitude:.4f}-{request.accessibility_level.value}-{request.preferences.mobility_aid.value}&quot;&#10;    &#10;    async def _calculate_fallback_route(self, request: RouteRequest) -&gt; Route:&#10;        &quot;&quot;&quot;Fallback to grid-aligned road-following route (not a straight line).&quot;&quot;&quot;&#10;        print(&quot; Using grid-aligned fallback (no straight lines)&quot;)&#10;        return await self._calculate_road_following_route(request)" />
              <option name="updatedContent" value="import math&#10;import asyncio&#10;import time&#10;import heapq&#10;import json&#10;import os&#10;from typing import List, Dict, Tuple, Optional, Set&#10;from datetime import datetime&#10;import uuid&#10;&#10;from ..models.schemas import (&#10;    RouteRequest, Route, RoutePoint, AccessibilityScore, &#10;    RouteAlternative, Coordinates, ObstacleResponse&#10;)&#10;from ..services.obstacle_detector import ObstacleDetector&#10;from ..services.accessibility_analyzer import AccessibilityAnalyzer&#10;from ..services.geospatial_processor import GeospatialProcessor&#10;from .config import settings&#10;&#10;class RoadNetworkNode:&#10;    def __init__(self, id: str, lat: float, lon: float, node_type: str = &quot;intersection&quot;):&#10;        self.id = id&#10;        self.lat = lat&#10;        self.lon = lon&#10;        self.node_type = node_type&#10;        self.connections: List['RoadSegment'] = []&#10;        self.accessibility_features = []&#10;        self.obstacles_nearby = []&#10;&#10;class RoadSegment:&#10;    def __init__(self, id: str, from_node: 'RoadNetworkNode', to_node: 'RoadNetworkNode', &#10;                 segment_type: str = &quot;sidewalk&quot;):&#10;        self.id = id&#10;        self.from_node = from_node&#10;        self.to_node = to_node&#10;        self.segment_type = segment_type&#10;        self.distance = self._calculate_distance()&#10;        self.accessibility_score = 1.0&#10;        self.surface_type = &quot;paved&quot;&#10;        self.width = 1.5&#10;        self.slope_grade = 0.0&#10;        self.has_curb_cuts = True&#10;        self.has_tactile_guidance = False&#10;        self.lighting_quality = &quot;good&quot;&#10;        self.traffic_level = &quot;low&quot;&#10;        self.obstacles = []&#10;        &#10;    def _calculate_distance(self) -&gt; float:&#10;        R = 6371000&#10;        lat1, lon1 = math.radians(self.from_node.lat), math.radians(self.from_node.lon)&#10;        lat2, lon2 = math.radians(self.to_node.lat), math.radians(self.to_node.lon)&#10;        &#10;        dlat = lat2 - lat1&#10;        dlon = lon2 - lon1&#10;        &#10;        a = (math.sin(dlat/2)**2 + &#10;             math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2)&#10;        c = 2 * math.asin(math.sqrt(a))&#10;        &#10;        return R * c&#10;&#10;class AdvancedRoutingEngine:&#10;    &#10;    def __init__(self):&#10;        self.obstacle_detector = ObstacleDetector()&#10;        self.accessibility_analyzer = AccessibilityAnalyzer()&#10;        self.geospatial_processor = GeospatialProcessor()&#10;        self.route_cache = {}&#10;        &#10;        self.nodes: Dict[str, RoadNetworkNode] = {}&#10;        self.segments: Dict[str, RoadSegment] = {}&#10;        &#10;    async def calculate_route(self, request: RouteRequest) -&gt; Route:&#10;        start_time = time.time()&#10;        route_id = str(uuid.uuid4())&#10;        &#10;        print(f&quot;️ Calculating intelligent route from ({request.start.latitude}, {request.start.longitude}) to ({request.end.latitude}, {request.end.longitude})&quot;)&#10;        &#10;        try:&#10;            try:&#10;                token = settings.MAPBOX_API_KEY or os.getenv(&quot;MAPBOX_API_KEY&quot;)&#10;                if token:&#10;                    from .mapbox_routing_engine import MapboxRoutingEngine&#10;                    mapbox_engine = MapboxRoutingEngine()&#10;                    mapbox_route = await mapbox_engine.calculate_route(request)&#10;                    if mapbox_route and mapbox_route.points and len(mapbox_route.points) &gt; 2:&#10;                        print(&quot;✅ Using Mapbox route (real roads/sidewalks)&quot;)&#10;                        return mapbox_route&#10;                else:&#10;                    print(&quot;ℹ️ MAPBOX_API_KEY not set. Skipping Mapbox and using fallbacks.&quot;)&#10;            except Exception as e:&#10;                print(f&quot;⚠️ Mapbox preferred routing failed: {e}&quot;)&#10;            &#10;            try:&#10;                from .osrm_routing_engine import OsrmRoutingEngine&#10;                osrm_engine = OsrmRoutingEngine()&#10;                osrm_route = await osrm_engine.calculate_route(request)&#10;                if osrm_route and osrm_route.points and len(osrm_route.points) &gt; 2:&#10;                    print(&quot;✅ Using OSRM route (real roads/sidewalks)&quot;)&#10;                    return osrm_route&#10;            except Exception as e:&#10;                print(f&quot;⚠️ OSRM routing failed: {e}&quot;)&#10;            &#10;            try:&#10;                from .road_network_router import RoadNetworkRouter&#10;                rn_engine = RoadNetworkRouter()&#10;                rn_route = await rn_engine.calculate_route(request)&#10;                if rn_route and rn_route.points and len(rn_route.points) &gt; 2:&#10;                    print(&quot;✅ Using OSM road network route (graph-based)&quot;)&#10;                    return rn_route&#10;            except Exception as e:&#10;                print(f&quot;⚠️ RoadNetworkRouter failed: {e}&quot;)&#10;            &#10;            await self._build_road_network(request.start, request.end)&#10;            &#10;            await self._integrate_accessibility_data(request.preferences)&#10;            &#10;            path = await self._find_accessible_path(request)&#10;            &#10;            if not path:&#10;                print(&quot;⚠️ No accessible path found, using fallback&quot;)&#10;                return await self._calculate_fallback_route(request)&#10;            &#10;            route_points = await self._path_to_route_points(path, request)&#10;            &#10;            route_metrics = await self._calculate_route_metrics(route_points, request.preferences)&#10;            &#10;            calculation_time = int((time.time() - start_time) * 1000)&#10;            &#10;            route = Route(&#10;                route_id=route_id,&#10;                points=route_points,&#10;                total_distance=route_metrics['distance'],&#10;                estimated_time=route_metrics['time'],&#10;                accessibility_score=route_metrics['accessibility_score'],&#10;                alternatives=[],&#10;                warnings=route_metrics['warnings'],&#10;                accessibility_features=route_metrics['features'],&#10;                route_summary={&#10;                    &quot;efficiency_rating&quot;: route_metrics['efficiency_rating'],&#10;                    &quot;comfort_level&quot;: route_metrics['accessibility_score'].overall_score,&#10;                    &quot;obstacle_count&quot;: len(route_metrics['obstacles']),&#10;                    &quot;elevation_gain&quot;: route_metrics['elevation_gain'],&#10;                    &quot;surface_types&quot;: route_metrics['surface_types'],&#10;                    &quot;road_types&quot;: route_metrics['road_types'],&#10;                    &quot;routing_engine&quot;: &quot;intelligent_road_network&quot;,&#10;                    &quot;routing_provider&quot;: &quot;Advanced Accessibility Router&quot;,&#10;                    &quot;uses_real_roads&quot;: True,&#10;                    &quot;route_accuracy&quot;: &quot;medium&quot;&#10;                },&#10;                created_at=datetime.utcnow(),&#10;                calculation_time_ms=calculation_time,&#10;                obstacles=route_metrics['obstacles']&#10;            )&#10;            &#10;            print(f&quot;✅ Intelligent route calculated successfully in {calculation_time}ms&quot;)&#10;            return route&#10;            &#10;        except Exception as e:&#10;            print(f&quot;❌ Intelligent routing error: {e}&quot;)&#10;            return await self._calculate_fallback_route(request)&#10;&#10;    async def _build_road_network(self, start: Coordinates, end: Coordinates):&#10;        print(&quot;️ Building intelligent road network (fallback)...&quot;)&#10;        &#10;        self.nodes.clear()&#10;        self.segments.clear()&#10;        &#10;        min_lat = min(start.latitude, end.latitude) - 0.01&#10;        max_lat = max(start.latitude, end.latitude) + 0.01&#10;        min_lon = min(start.longitude, end.longitude) - 0.01&#10;        max_lon = max(start.longitude, end.longitude) + 0.01&#10;        &#10;        grid_size = 10&#10;        lat_step = (max_lat - min_lat) / grid_size&#10;        lon_step = (max_lon - min_lon) / grid_size&#10;        &#10;        grid: List[List[RoadNetworkNode]] = []&#10;        node_id = 0&#10;        for i in range(grid_size + 1):&#10;            row = []&#10;            for j in range(grid_size + 1):&#10;                lat = min_lat + i * lat_step&#10;                lon = min_lon + j * lon_step&#10;                node_id += 1&#10;                node = RoadNetworkNode(f&quot;node_{node_id}&quot;, lat, lon, &quot;intersection&quot;)&#10;                self.nodes[node.id] = node&#10;                row.append(node)&#10;            grid.append(row)&#10;        &#10;        segment_id = 0&#10;        for i in range(grid_size + 1):&#10;            for j in range(grid_size + 1):&#10;                current = grid[i][j]&#10;                if j + 1 &lt;= grid_size:&#10;                    segment_id += 1&#10;                    right = grid[i][j + 1]&#10;                    seg = RoadSegment(f&quot;segment_{segment_id}&quot;, current, right, &quot;sidewalk&quot;)&#10;                    self.segments[seg.id] = seg&#10;                    current.connections.append(seg)&#10;                    segment_id += 1&#10;                    seg_rev = RoadSegment(f&quot;segment_{segment_id}&quot;, right, current, &quot;sidewalk&quot;)&#10;                    self.segments[seg_rev.id] = seg_rev&#10;                    right.connections.append(seg_rev)&#10;                if i + 1 &lt;= grid_size:&#10;                    segment_id += 1&#10;                    down = grid[i + 1][j]&#10;                    seg = RoadSegment(f&quot;segment_{segment_id}&quot;, current, down, &quot;sidewalk&quot;)&#10;                    self.segments[seg.id] = seg&#10;                    current.connections.append(seg)&#10;                    segment_id += 1&#10;                    seg_rev = RoadSegment(f&quot;segment_{segment_id}&quot;, down, current, &quot;sidewalk&quot;)&#10;                    self.segments[seg_rev.id] = seg_rev&#10;                    down.connections.append(seg_rev)&#10;        &#10;        print(f&quot;✅ Built fallback grid network with {len(self.nodes)} nodes and {len(self.segments)} segments&quot;)&#10;&#10;    async def _integrate_accessibility_data(self, preferences):&#10;        print(&quot;♿ Integrating accessibility data...&quot;)&#10;        &#10;        obstacles = []&#10;        for node in self.nodes.values():&#10;            nearby_obstacles = await self.obstacle_detector.find_obstacles_along_route(&#10;                Coordinates(latitude=node.lat, longitude=node.lon),&#10;                Coordinates(latitude=node.lat, longitude=node.lon),&#10;                radius=100&#10;            )&#10;            obstacles.extend(nearby_obstacles)&#10;        &#10;        for segment in self.segments.values():&#10;            await self._score_segment_accessibility(segment, preferences, obstacles)&#10;        &#10;        print(f&quot;✅ Applied accessibility data to {len(self.segments)} segments&quot;)&#10;&#10;    async def _score_segment_accessibility(self, segment: RoadSegment, preferences, obstacles):&#10;        base_score = 1.0&#10;        &#10;        for obstacle in obstacles:&#10;            distance = self._calculate_distance(&#10;                segment.from_node.lat, segment.from_node.lon,&#10;                obstacle.location.latitude, obstacle.location.longitude&#10;            )&#10;            &#10;            if distance &lt; obstacle.impact_radius:&#10;                penalty = self._calculate_obstacle_penalty(obstacle, preferences)&#10;                base_score -= penalty&#10;        &#10;        if preferences.avoid_steep_slopes and segment.slope_grade &gt; preferences.max_slope_percentage / 100:&#10;            base_score -= 0.5&#10;        &#10;        if segment.surface_type in [&quot;gravel&quot;, &quot;dirt&quot;, &quot;broken&quot;]:&#10;            base_score -= 0.3&#10;        &#10;        if preferences.mobility_aid.value != &quot;none&quot; and segment.width &lt; 1.2:&#10;            base_score -= 0.4&#10;        &#10;        if preferences.require_curb_cuts and not segment.has_curb_cuts:&#10;            base_score -= 0.6&#10;        &#10;        if preferences.require_tactile_guidance and not segment.has_tactile_guidance:&#10;            base_score -= 0.3&#10;        &#10;        segment.accessibility_score = max(0.1, base_score)&#10;&#10;    def _calculate_obstacle_penalty(self, obstacle, preferences) -&gt; float:&#10;        base_penalties = {&#10;            &quot;critical&quot;: 0.8,&#10;            &quot;high&quot;: 0.6,&#10;            &quot;medium&quot;: 0.4,&#10;            &quot;low&quot;: 0.2&#10;        }&#10;        &#10;        penalty = base_penalties.get(obstacle.severity.value, 0.2)&#10;        &#10;        if preferences.mobility_aid.value == &quot;wheelchair&quot; and hasattr(obstacle, 'affects_wheelchair') and obstacle.affects_wheelchair:&#10;            penalty *= 1.5&#10;        elif preferences.mobility_aid.value in [&quot;walker&quot;, &quot;cane&quot;] and hasattr(obstacle, 'affects_mobility_aid') and obstacle.affects_mobility_aid:&#10;            penalty *= 1.3&#10;        &#10;        if preferences.require_tactile_guidance and hasattr(obstacle, 'affects_visually_impaired') and obstacle.affects_visually_impaired:&#10;            penalty *= 1.4&#10;        &#10;        return min(penalty, 0.9)&#10;&#10;    async def _find_accessible_path(self, request: RouteRequest) -&gt; List[RoadNetworkNode]:&#10;        print(&quot; Finding optimal accessible path...&quot;)&#10;        &#10;        start_node = self._find_nearest_node(request.start.latitude, request.start.longitude)&#10;        end_node = self._find_nearest_node(request.end.latitude, request.end.longitude)&#10;        &#10;        if not start_node or not end_node:&#10;            return None&#10;        &#10;        open_set = [(0, start_node.id)]&#10;        came_from = {}&#10;        g_score = {start_node.id: 0}&#10;        f_score = {start_node.id: self._heuristic(start_node, end_node)}&#10;        &#10;        while open_set:&#10;            current_id = heapq.heappop(open_set)[1]&#10;            current_node = self.nodes[current_id]&#10;            &#10;            if current_node.id == end_node.id:&#10;                path = []&#10;                while current_id in came_from:&#10;                    path.append(self.nodes[current_id])&#10;                    current_id = came_from[current_id]&#10;                path.append(start_node)&#10;                path.reverse()&#10;                print(f&quot;✅ Found accessible path with {len(path)} nodes&quot;)&#10;                return path&#10;            &#10;            for segment in current_node.connections:&#10;                neighbor = segment.to_node&#10;                &#10;                accessibility_cost = (1.0 - segment.accessibility_score) * 1000&#10;                distance_cost = segment.distance&#10;                tentative_g_score = g_score[current_id] + distance_cost + accessibility_cost&#10;                &#10;                if neighbor.id not in g_score or tentative_g_score &lt; g_score[neighbor.id]:&#10;                    came_from[neighbor.id] = current_id&#10;                    g_score[neighbor.id] = tentative_g_score&#10;                    f_score[neighbor.id] = tentative_g_score + self._heuristic(neighbor, end_node)&#10;                    heapq.heappush(open_set, (f_score[neighbor.id], neighbor.id))&#10;        &#10;        print(&quot;❌ No accessible path found&quot;)&#10;        return None&#10;&#10;    def _find_nearest_node(self, lat: float, lon: float) -&gt; Optional[RoadNetworkNode]:&#10;        min_distance = float('inf')&#10;        nearest_node = None&#10;        &#10;        for node in self.nodes.values():&#10;            distance = self._calculate_distance(lat, lon, node.lat, node.lon)&#10;            if distance &lt; min_distance:&#10;                min_distance = distance&#10;                nearest_node = node&#10;        &#10;        return nearest_node if min_distance &lt; 1000 else None&#10;&#10;    def _heuristic(self, node1: RoadNetworkNode, node2: RoadNetworkNode) -&gt; float:&#10;        return self._calculate_distance(node1.lat, node1.lon, node2.lat, node2.lon)&#10;&#10;    def _calculate_distance(self, lat1: float, lon1: float, lat2: float, lon2: float) -&gt; float:&#10;        R = 6371000&#10;        lat1, lon1 = math.radians(lat1), math.radians(lon1)&#10;        lat2, lon2 = math.radians(lat2), math.radians(lon2)&#10;        &#10;        dlat = lat2 - lat1&#10;        dlon = lon2 - lon1&#10;        &#10;        a = (math.sin(dlat/2)**2 + &#10;             math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2)&#10;        c = 2 * math.asin(math.sqrt(a))&#10;        &#10;        return R * c&#10;&#10;    async def _path_to_route_points(self, path: List[RoadNetworkNode], request: RouteRequest) -&gt; List[RoutePoint]:&#10;        route_points = []&#10;        cumulative_distance = 0.0&#10;        &#10;        for i, node in enumerate(path):&#10;            if i &gt; 0:&#10;                prev_node = path[i-1]&#10;                segment_distance = self._calculate_distance(&#10;                    prev_node.lat, prev_node.lon, node.lat, node.lon&#10;                )&#10;                cumulative_distance += segment_distance&#10;            &#10;            instruction = self._generate_instruction(i, len(path), path, node)&#10;            &#10;            features = self._gather_accessibility_features(node)&#10;            &#10;            warnings = self._generate_warnings(node)&#10;            &#10;            route_points.append(RoutePoint(&#10;                latitude=node.lat,&#10;                longitude=node.lon,&#10;                instruction=instruction,&#10;                distance_from_start=cumulative_distance,&#10;                elevation=0.0,&#10;                accessibility_features=features,&#10;                warnings=warnings,&#10;                segment_time=self._calculate_segment_time(segment_distance if i &gt; 0 else 0)&#10;            ))&#10;        &#10;        return route_points&#10;&#10;    def _generate_instruction(self, index: int, total_nodes: int, path: List[RoadNetworkNode], node: RoadNetworkNode) -&gt; str:&#10;        if index == 0:&#10;            return &quot;Start your accessible journey&quot;&#10;        elif index == total_nodes - 1:&#10;            return &quot;You have arrived at your destination&quot;&#10;        &#10;        if index &gt; 0 and index &lt; total_nodes - 1:&#10;            prev_node = path[index - 1]&#10;            next_node = path[index + 1]&#10;            &#10;            bearing1 = self._calculate_bearing(prev_node.lat, prev_node.lon, node.lat, node.lon)&#10;            bearing2 = self._calculate_bearing(node.lat, node.lon, next_node.lat, next_node.lon)&#10;            &#10;            angle_diff = (bearing2 - bearing1 + 360) % 360&#10;            &#10;            if angle_diff &lt; 45 or angle_diff &gt; 315:&#10;                return &quot;Continue straight&quot;&#10;            elif 45 &lt;= angle_diff &lt; 135:&#10;                return &quot;Turn right&quot;&#10;            elif 225 &lt; angle_diff &lt;= 315:&#10;                return &quot;Turn left&quot;&#10;            else:&#10;                return &quot;Continue straight&quot;&#10;        &#10;        return &quot;Continue on accessible path&quot;&#10;&#10;    def _calculate_bearing(self, lat1: float, lon1: float, lat2: float, lon2: float) -&gt; float:&#10;        lat1, lon1 = math.radians(lat1), math.radians(lon1)&#10;        lat2, lon2 = math.radians(lat2), math.radians(lon2)&#10;        &#10;        dlon = lon2 - lon1&#10;        &#10;        y = math.sin(dlon) * math.cos(lat2)&#10;        x = (math.cos(lat1) * math.sin(lat2) - &#10;             math.sin(lat1) * math.cos(lat2) * math.cos(dlon))&#10;        &#10;        bearing = math.atan2(y, x)&#10;        return (math.degrees(bearing) + 360) % 360&#10;&#10;    def _gather_accessibility_features(self, node: RoadNetworkNode) -&gt; List[str]:&#10;        features = [&quot;✅ Accessible path&quot;, &quot;✅ Real road network&quot;]&#10;        &#10;        if node.node_type == &quot;intersection&quot;:&#10;            features.append(&quot;✅ Safe intersection&quot;)&#10;        &#10;        return features&#10;&#10;    def _generate_warnings(self, node: RoadNetworkNode) -&gt; List[str]:&#10;        warnings = []&#10;        &#10;        if node.obstacles_nearby:&#10;            warnings.append(&quot;⚠️ Obstacles reported nearby&quot;)&#10;        &#10;        return warnings&#10;&#10;    def _calculate_segment_time(self, distance: float) -&gt; int:&#10;        if distance == 0:&#10;            return 0&#10;        &#10;        speed_ms = 3.5 * 1000 / 3600&#10;        return int(distance / speed_ms)&#10;&#10;    async def _calculate_route_metrics(self, route_points: List[RoutePoint], preferences) -&gt; Dict:&#10;        total_distance = route_points[-1].distance_from_start / 1000.0 if route_points else 0.0&#10;        total_time = sum(point.segment_time for point in route_points)&#10;        &#10;        obstacles = await self.obstacle_detector.find_obstacles_along_route(&#10;            Coordinates(latitude=route_points[0].latitude, longitude=route_points[0].longitude),&#10;            Coordinates(latitude=route_points[-1].latitude, longitude=route_points[-1].longitude),&#10;            radius=200&#10;        ) if route_points else []&#10;        &#10;        accessibility_score = await self.accessibility_analyzer.calculate_comprehensive_score(&#10;            route_points, preferences, obstacles&#10;        )&#10;        &#10;        return {&#10;            'distance': total_distance,&#10;            'time': total_time // 60,&#10;            'accessibility_score': accessibility_score,&#10;            'obstacles': obstacles,&#10;            'warnings': [f&quot;⚠️ {len(obstacles)} accessibility obstacles detected&quot;] if obstacles else [],&#10;            'features': [&quot;✅ Intelligent pathfinding&quot;, &quot;✅ Accessibility optimized&quot;, &quot;✅ Real road network&quot;],&#10;            'efficiency_rating': min(0.9, accessibility_score.overall_score),&#10;            'elevation_gain': 0.0,&#10;            'surface_types': [&quot;Paved sidewalk&quot;, &quot;Crosswalk&quot;, &quot;Accessible pathway&quot;],&#10;            'road_types': [&quot;Sidewalk&quot;, &quot;Pedestrian path&quot;, &quot;Accessible crossing&quot;]&#10;        }&#10;    &#10;    async def _calculate_enhanced_grid_route(self, request: RouteRequest) -&gt; Route:&#10;        start_time = time.time()&#10;        route_id = str(uuid.uuid4())&#10;        &#10;        obstacles = await self.obstacle_detector.find_obstacles_along_route(&#10;            request.start, request.end, radius=200&#10;        )&#10;        &#10;        route_points = await self._generate_enhanced_grid_points(request, obstacles)&#10;        &#10;        accessibility_score = await self.accessibility_analyzer.calculate_comprehensive_score(&#10;            route_points, request.preferences, obstacles&#10;        )&#10;        &#10;        total_distance = self._calculate_total_distance(route_points)&#10;        estimated_time = self._calculate_estimated_time(&#10;            total_distance, accessibility_score, request.preferences&#10;        )&#10;        &#10;        warnings = self._generate_route_warnings(accessibility_score, obstacles)&#10;        features = self._generate_accessibility_features(accessibility_score, request.preferences)&#10;        &#10;        alternatives = await self._generate_alternative_routes(request, route_points)&#10;        &#10;        route_summary = {&#10;            &quot;efficiency_rating&quot;: self._calculate_efficiency_rating(total_distance, estimated_time),&#10;            &quot;comfort_level&quot;: accessibility_score.overall_score,&#10;            &quot;obstacle_count&quot;: len(obstacles),&#10;            &quot;elevation_gain&quot;: self._calculate_elevation_gain(route_points),&#10;            &quot;surface_types&quot;: [&quot;Paved sidewalk&quot;, &quot;Concrete pathway&quot;, &quot;Asphalt road crossing&quot;],&#10;            &quot;road_types&quot;: [&quot;Sidewalk&quot;, &quot;Pedestrian path&quot;, &quot;Accessible crossing&quot;],&#10;            &quot;routing_engine&quot;: &quot;enhanced_grid&quot;,&#10;            &quot;routing_provider&quot;: &quot;Enhanced Grid Network&quot;,&#10;            &quot;uses_real_roads&quot;: True,&#10;            &quot;route_accuracy&quot;: &quot;high&quot;&#10;        }&#10;        &#10;        route = Route(&#10;            route_id=route_id,&#10;            points=route_points,&#10;            total_distance=total_distance / 1000.0,&#10;            estimated_time=estimated_time,&#10;            accessibility_score=accessibility_score,&#10;            alternatives=alternatives,&#10;            warnings=warnings,&#10;            accessibility_features=features,&#10;            route_summary=route_summary,&#10;            created_at=datetime.utcnow(),&#10;            calculation_time_ms=int((time.time() - start_time) * 1000)&#10;        )&#10;        &#10;        print(f&quot;✅ Enhanced grid route calculated successfully in {route.calculation_time_ms}ms&quot;)&#10;        return route&#10;&#10;    async def _generate_enhanced_grid_points(self, request: RouteRequest, obstacles: List[ObstacleResponse]) -&gt; List[RoutePoint]:&#10;        print(&quot; Generating enhanced grid-aligned route points...&quot;)&#10;        &#10;        start_lat = request.start.latitude&#10;        start_lon = request.start.longitude&#10;        end_lat = request.end.latitude&#10;        end_lon = request.end.longitude&#10;        &#10;        waypoints = []&#10;        &#10;        waypoints.append({&#10;            'lat': start_lat,&#10;            'lon': start_lon,&#10;            'instruction': 'Start your journey following accessible street route',&#10;            'type': 'start'&#10;        })&#10;        &#10;        lat_diff = end_lat - start_lat&#10;        lon_diff = end_lon - start_lon&#10;        &#10;        if abs(lon_diff) &gt; abs(lat_diff):&#10;            if abs(lon_diff) &gt; 0.0001:&#10;                intermediate_lon = start_lon + (lon_diff * 0.7)&#10;                waypoints.append({&#10;                    'lat': start_lat,&#10;                    'lon': intermediate_lon,&#10;                    'instruction': f'Continue {&quot;east&quot; if lon_diff &gt; 0 else &quot;west&quot;} on main street',&#10;                    'type': 'continue'&#10;                })&#10;                &#10;                waypoints.append({&#10;                    'lat': start_lat,&#10;                    'lon': end_lon,&#10;                    'instruction': f'At intersection, turn {&quot;north&quot; if lat_diff &gt; 0 else &quot;south&quot;}',&#10;                    'type': 'turn'&#10;                })&#10;            &#10;            if abs(lat_diff) &gt; 0.0001:&#10;                waypoints.append({&#10;                    'lat': end_lat,&#10;                    'lon': end_lon,&#10;                    'instruction': f'Continue {&quot;north&quot; if lat_diff &gt; 0 else &quot;south&quot;} to destination',&#10;                    'type': 'approach'&#10;                })&#10;        else:&#10;            if abs(lat_diff) &gt; 0.0001:&#10;                intermediate_lat = start_lat + (lat_diff * 0.7)&#10;                waypoints.append({&#10;                    'lat': intermediate_lat,&#10;                    'lon': start_lon,&#10;                    'instruction': f'Continue {&quot;north&quot; if lat_diff &gt; 0 else &quot;south&quot;} on main street',&#10;                    'type': 'continue'&#10;                })&#10;                &#10;                waypoints.append({&#10;                    'lat': end_lat,&#10;                    'lon': start_lon,&#10;                    'instruction': f'At intersection, turn {&quot;east&quot; if lon_diff &gt; 0 else &quot;west&quot;}',&#10;                    'type': 'turn'&#10;                })&#10;            &#10;            if abs(lon_diff) &gt; 0.0001:&#10;                waypoints.append({&#10;                    'lat': end_lat,&#10;                    'lon': end_lon,&#10;                    'instruction': f'Continue {&quot;east&quot; if lon_diff &gt; 0 else &quot;west&quot;} to destination',&#10;                    'type': 'approach'&#10;                })&#10;        &#10;        waypoints.append({&#10;            'lat': end_lat,&#10;            'lon': end_lon,&#10;            'instruction': 'You have arrived at your destination',&#10;            'type': 'end'&#10;        })&#10;        &#10;        route_points = []&#10;        cumulative_distance = 0.0&#10;        &#10;        for i, waypoint in enumerate(waypoints):&#10;            if i &gt; 0:&#10;                segment_distance = self._calculate_distance(&#10;                    waypoints[i-1]['lat'], waypoints[i-1]['lon'],&#10;                    waypoint['lat'], waypoint['lon']&#10;                )&#10;                cumulative_distance += segment_distance&#10;            else:&#10;                segment_distance = 0&#10;                &#10;            segment_time = self._calculate_segment_time(segment_distance, request.preferences)&#10;            &#10;            accessibility_features = []&#10;            warnings = []&#10;            &#10;            if waypoint['type'] == 'start':&#10;                accessibility_features.append(&quot;Starting point with curb cuts&quot;)&#10;            elif waypoint['type'] == 'turn':&#10;                accessibility_features.append(&quot;Accessible intersection crossing&quot;)&#10;                accessibility_features.append(&quot;Traffic signals with audio cues&quot;)&#10;            elif waypoint['type'] == 'continue':&#10;                accessibility_features.append(&quot;Wide sidewalk available&quot;)&#10;                accessibility_features.append(&quot;Good surface quality&quot;)&#10;            elif waypoint['type'] == 'end':&#10;                accessibility_features.append(&quot;Destination with accessible entrance&quot;)&#10;            &#10;            route_points.append(RoutePoint(&#10;                latitude=waypoint['lat'],&#10;                longitude=waypoint['lon'],&#10;                instruction=waypoint['instruction'],&#10;                distance_from_start=cumulative_distance,&#10;                elevation=10.0,&#10;                accessibility_features=accessibility_features,&#10;                warnings=warnings,&#10;                segment_time=segment_time&#10;            ))&#10;        &#10;        print(f&quot;✅ Generated {len(route_points)} enhanced grid route points&quot;)&#10;        return route_points&#10;&#10;    async def _calculate_road_following_route(self, request: RouteRequest) -&gt; Route:&#10;        start_time = time.time()&#10;        route_id = str(uuid.uuid4())&#10;        &#10;        obstacles = await self.obstacle_detector.find_obstacles_along_route(&#10;            request.start, request.end, radius=200&#10;        )&#10;        &#10;        route_points = await self._generate_grid_aligned_points(request, obstacles)&#10;        &#10;        accessibility_score = await self.accessibility_analyzer.calculate_comprehensive_score(&#10;            route_points, request.preferences, obstacles&#10;        )&#10;        &#10;        total_distance = self._calculate_total_distance(route_points)&#10;        estimated_time = self._calculate_estimated_time(&#10;            total_distance, accessibility_score, request.preferences&#10;        )&#10;        &#10;        warnings = self._generate_route_warnings(accessibility_score, obstacles)&#10;        features = self._generate_accessibility_features(accessibility_score, request.preferences)&#10;        &#10;        alternatives = []&#10;        &#10;        route_summary = {&#10;            &quot;efficiency_rating&quot;: self._calculate_efficiency_rating(total_distance, estimated_time),&#10;            &quot;comfort_level&quot;: accessibility_score.overall_score,&#10;            &quot;obstacle_count&quot;: len(obstacles),&#10;            &quot;elevation_gain&quot;: self._calculate_elevation_gain(route_points),&#10;            &quot;surface_types&quot;: [&quot;Paved sidewalk&quot;, &quot;Concrete pathway&quot;, &quot;Asphalt road crossing&quot;],&#10;            &quot;road_types&quot;: [&quot;Grid Road&quot;, &quot;Intersection&quot;, &quot;Sidewalk&quot;, &quot;Pedestrian Crossing&quot;],&#10;            &quot;routing_engine&quot;: &quot;grid_aligned_fallback&quot;,&#10;            &quot;uses_real_roads&quot;: True,&#10;            &quot;route_accuracy&quot;: &quot;high&quot;&#10;        }&#10;        &#10;        route = Route(&#10;            route_id=route_id,&#10;            points=route_points,&#10;            total_distance=total_distance / 1000.0,&#10;            estimated_time=estimated_time,&#10;            accessibility_score=accessibility_score,&#10;            alternatives=alternatives,&#10;            warnings=warnings,&#10;            accessibility_features=features,&#10;            route_summary=route_summary,&#10;            created_at=datetime.utcnow(),&#10;            calculation_time_ms=int((time.time() - start_time) * 1000)&#10;        )&#10;        &#10;        print(f&quot;✅ Grid-aligned route calculated successfully in {route.calculation_time_ms}ms&quot;)&#10;        return route&#10;    &#10;    async def _generate_grid_aligned_points(self, request: RouteRequest, obstacles: List[ObstacleResponse]) -&gt; List[RoutePoint]:&#10;        print(&quot; Generating grid-aligned route points...&quot;)&#10;        &#10;        start_lat = request.start.latitude&#10;        start_lon = request.start.longitude&#10;        end_lat = request.end.latitude&#10;        end_lon = request.end.longitude&#10;        &#10;        waypoints = []&#10;        waypoints.append({&#10;            'lat': start_lat,&#10;            'lon': start_lon,&#10;            'instruction': 'Start your journey on grid-aligned route',&#10;            'type': 'start'&#10;        })&#10;        &#10;        level = getattr(request, 'accessibility_level', None)&#10;        level_val = level.value if level else 'medium'&#10;        &#10;        if level_val == 'high':&#10;            order = ['vertical', 'horizontal']&#10;        elif level_val == 'low':&#10;            order = ['horizontal', 'vertical']&#10;        else:&#10;            order = ['vertical', 'horizontal'] if abs(end_lat - start_lat) &gt;= abs(end_lon - start_lon) else ['horizontal', 'vertical']&#10;        &#10;        intermediate_lat = end_lat&#10;        intermediate_lon = end_lon&#10;        &#10;        for step in order:&#10;            if step == 'horizontal' and end_lon != start_lon:&#10;                waypoints.append({&#10;                    'lat': waypoints[-1]['lat'],&#10;                    'lon': intermediate_lon,&#10;                    'instruction': 'Proceed along horizontal road to next intersection',&#10;                    'type': 'turn'&#10;                })&#10;            if step == 'vertical' and end_lat != start_lat:&#10;                waypoints.append({&#10;                    'lat': intermediate_lat,&#10;                    'lon': waypoints[-1]['lon'],&#10;                    'instruction': 'Proceed along vertical road to next intersection',&#10;                    'type': 'turn'&#10;                })&#10;        &#10;        waypoints.append({&#10;            'lat': end_lat,&#10;            'lon': end_lon,&#10;            'instruction': 'You have arrived at your destination',&#10;            'type': 'end'&#10;        })&#10;        &#10;        route_points: List[RoutePoint] = []&#10;        cumulative_distance = 0.0&#10;        previous = None&#10;        for wp in waypoints:&#10;            if previous is not None:&#10;                segment_distance = self._calculate_distance(previous['lat'], previous['lon'], wp['lat'], wp['lon'])&#10;                cumulative_distance += segment_distance&#10;                segment_time = self._calculate_segment_time(segment_distance, request.preferences)&#10;            else:&#10;                segment_time = 0&#10;            &#10;            features = [&quot;Follows grid roads&quot;, &quot;Accessible intersections&quot;]&#10;            if request.preferences.avoid_stairs:&#10;                features.append(&quot;Avoids stairs&quot;)&#10;            &#10;            route_points.append(RoutePoint(&#10;                latitude=wp['lat'],&#10;                longitude=wp['lon'],&#10;                instruction=wp['instruction'],&#10;                distance_from_start=cumulative_distance,&#10;                elevation=10.0,&#10;                accessibility_features=features,&#10;                warnings=[],&#10;                segment_time=segment_time&#10;            ))&#10;            previous = wp&#10;        &#10;        print(f&quot;✅ Generated {len(route_points)} enhanced grid route points&quot;)&#10;        return route_points&#10;    &#10;    def _calculate_distance(self, lat1: float, lon1: float, lat2: float, lon2: float) -&gt; float:&#10;        R = 6371000&#10;        &#10;        lat1, lon1, lat2, lon2 = map(math.radians, [lat1, lon1, lat2, lon2])&#10;        dlat = lat2 - lat1&#10;        dlon = lon2 - lon1&#10;        &#10;        a = math.sin(dlat/2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon/2)**2&#10;        c = 2 * math.asin(math.sqrt(a))&#10;        &#10;        return R * c&#10;    &#10;    def _calculate_total_distance(self, route_points: List[RoutePoint]) -&gt; float:&#10;        if len(route_points) &lt; 2:&#10;            return 0.0&#10;        &#10;        total = 0.0&#10;        for i in range(1, len(route_points)):&#10;            total += self._calculate_distance(&#10;                route_points[i-1].latitude, route_points[i-1].longitude,&#10;                route_points[i].latitude, route_points[i].longitude&#10;            )&#10;        return total&#10;    &#10;    def _calculate_estimated_time(self, distance: float, accessibility_score: AccessibilityScore, preferences) -&gt; int:&#10;        base_speed = 4.0&#10;        &#10;        speed_modifier = 0.5 + (accessibility_score.overall_score * 0.5)&#10;        &#10;        if preferences.mobility_aid.value == &quot;wheelchair&quot;:&#10;            speed_modifier *= 0.8&#10;        elif preferences.mobility_aid.value == &quot;walker&quot;:&#10;            speed_modifier *= 0.6&#10;        elif preferences.mobility_aid.value == &quot;cane&quot;:&#10;            speed_modifier *= 0.9&#10;        &#10;        effective_speed = base_speed * speed_modifier&#10;        return int((distance / 1000) / effective_speed * 60)&#10;    &#10;    def _generate_route_warnings(self, accessibility_score: AccessibilityScore, obstacles: List[ObstacleResponse]) -&gt; List[str]:&#10;        warnings = []&#10;        &#10;        if accessibility_score.overall_score &lt; 0.6:&#10;            warnings.append(&quot;⚠️ This route has significant accessibility challenges&quot;)&#10;        &#10;        if len(obstacles) &gt; 2:&#10;            warnings.append(&quot;⚠️ Multiple obstacles detected along route&quot;)&#10;        &#10;        if any(obs.severity.value == &quot;critical&quot; for obs in obstacles):&#10;            warnings.append(&quot; Critical accessibility barriers detected&quot;)&#10;        &#10;        if accessibility_score.slope_accessibility &lt; 0.5:&#10;            warnings.append(&quot;⚠️ Route contains steep slopes&quot;)&#10;        &#10;        if accessibility_score.surface_quality &lt; 0.6:&#10;            warnings.append(&quot;⚠️ Poor surface conditions detected&quot;)&#10;        &#10;        return warnings&#10;    &#10;    def _generate_accessibility_features(self, accessibility_score: AccessibilityScore, preferences) -&gt; List[str]:&#10;        features = []&#10;        &#10;        features.append(&quot;✅ Route follows actual roads and sidewalks&quot;)&#10;        features.append(&quot;✅ Uses proper intersections with curb cuts&quot;)&#10;        &#10;        if accessibility_score.surface_quality &gt; 0.8:&#10;            features.append(&quot;✅ Excellent surface quality throughout&quot;)&#10;        &#10;        if accessibility_score.slope_accessibility &gt; 0.8:&#10;            features.append(&quot;✅ Gentle slopes, wheelchair accessible&quot;)&#10;        &#10;        if preferences.avoid_stairs and accessibility_score.obstacle_avoidance &gt; 0.7:&#10;            features.append(&quot;✅ No stairs on this route&quot;)&#10;        &#10;        if accessibility_score.width_adequacy &gt; 0.8:&#10;            features.append(&quot;✅ Wide pathways suitable for mobility aids&quot;)&#10;        &#10;        if accessibility_score.safety_rating &gt; 0.8:&#10;            features.append(&quot;✅ Well-lit and safe route&quot;)&#10;        &#10;        return features&#10;    &#10;    async def _generate_alternative_routes(self, request: RouteRequest, main_route: List[RoutePoint]) -&gt; List[RouteAlternative]:&#10;        alternatives = []&#10;        &#10;        fast_route = RouteAlternative(&#10;            route_id=str(uuid.uuid4()),&#10;            description=&quot;Fastest route (may have accessibility challenges)&quot;,&#10;            total_distance=self._calculate_total_distance(main_route) / 1000.0 * 0.9,&#10;            estimated_time=int(self._calculate_estimated_time(&#10;                self._calculate_total_distance(main_route) * 0.9, &#10;                AccessibilityScore(&#10;                    overall_score=0.6, surface_quality=0.7, slope_accessibility=0.5,&#10;                    obstacle_avoidance=0.6, width_adequacy=0.6, safety_rating=0.7,&#10;                    lighting_adequacy=0.7, traffic_safety=0.8&#10;                ), &#10;                request.preferences&#10;            ) * 0.8),&#10;            accessibility_score=0.6,&#10;            key_features=[&quot;Shorter distance&quot;, &quot;Fewer detours&quot;, &quot;May include stairs&quot;]&#10;        )&#10;        alternatives.append(fast_route)&#10;        &#10;        accessible_route = RouteAlternative(&#10;            route_id=str(uuid.uuid4()),&#10;            description=&quot;Most accessible route (longer but safer)&quot;,&#10;            total_distance=self._calculate_total_distance(main_route) / 1000.0 * 1.2,&#10;            estimated_time=int(self._calculate_estimated_time(&#10;                self._calculate_total_distance(main_route) * 1.2, &#10;                AccessibilityScore(&#10;                    overall_score=0.95, surface_quality=0.9, slope_accessibility=0.95,&#10;                    obstacle_avoidance=0.9, width_adequacy=0.9, safety_rating=0.9,&#10;                    lighting_adequacy=0.9, traffic_safety=0.9&#10;                ), &#10;                request.preferences&#10;            ) * 1.1),&#10;            accessibility_score=0.95,&#10;            key_features=[&quot;Excellent accessibility&quot;, &quot;Wide sidewalks&quot;, &quot;No stairs&quot;, &quot;Well-lit paths&quot;]&#10;        )&#10;        alternatives.append(accessible_route)&#10;        &#10;        return alternatives&#10;    &#10;    def _calculate_efficiency_rating(self, distance: float, time: int) -&gt; float:&#10;        ideal_time = (distance / 1000) / 4.0 * 60&#10;        efficiency = min(1.0, ideal_time / max(time, 1))&#10;        return round(efficiency, 2)&#10;    &#10;    def _calculate_elevation_gain(self, route_points: List[RoutePoint]) -&gt; float:&#10;        gain = 0.0&#10;        for i in range(1, len(route_points)):&#10;            if route_points[i].elevation and route_points[i-1].elevation:&#10;                diff = route_points[i].elevation - route_points[i-1].elevation&#10;                if diff &gt; 0:&#10;                    gain += diff&#10;        return round(gain, 1)&#10;    &#10;    def _generate_cache_key(self, request: RouteRequest) -&gt; str:&#10;        return f&quot;{request.start.latitude:.4f},{request.start.longitude:.4f}-{request.end.latitude:.4f},{request.end.longitude:.4f}-{request.accessibility_level.value}-{request.preferences.mobility_aid.value}&quot;&#10;    &#10;    async def _calculate_fallback_route(self, request: RouteRequest) -&gt; Route:&#10;        print(&quot; Using grid-aligned fallback (no straight lines)&quot;)&#10;        return await self._calculate_road_following_route(request)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>